// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package valhalla

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings(in *jlexer.Lexer, out *TraceRouteRequest) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "begin_time":
			if in.IsNull() {
				in.Skip()
				out.BeginTime = nil
			} else {
				if out.BeginTime == nil {
					out.BeginTime = new(float64)
				}
				*out.BeginTime = float64(in.Float64())
			}
		case "durations":
			if in.IsNull() {
				in.Skip()
				out.Durations = nil
			} else {
				in.Delim('[')
				if out.Durations == nil {
					if !in.IsDelim(']') {
						out.Durations = make([]int64, 0, 8)
					} else {
						out.Durations = []int64{}
					}
				} else {
					out.Durations = (out.Durations)[:0]
				}
				for !in.IsDelim(']') {
					var v1 int64
					v1 = int64(in.Int64())
					out.Durations = append(out.Durations, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "use_timestamps":
			out.UseTimestamps = bool(in.Bool())
		case "costing":
			out.Costing = string(in.String())
		case "directions_options":
			(out.DirectionsOptions).UnmarshalEasyJSON(in)
		case "trace_options":
			(out.TraceOptions).UnmarshalEasyJSON(in)
		case "linear_references":
			out.LinearReferences = bool(in.Bool())
		case "encoded_polyline":
			out.EncodedPolyline = string(in.String())
		case "shape_match":
			out.ShapeMatch = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings(out *jwriter.Writer, in TraceRouteRequest) {
	out.RawByte('{')
	first := true
	_ = first
	if in.BeginTime != nil {
		const prefix string = ",\"begin_time\":"
		first = false
		out.RawString(prefix[1:])
		out.Float64(float64(*in.BeginTime))
	}
	if len(in.Durations) != 0 {
		const prefix string = ",\"durations\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v2, v3 := range in.Durations {
				if v2 > 0 {
					out.RawByte(',')
				}
				out.Int64(int64(v3))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"use_timestamps\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.UseTimestamps))
	}
	if in.Costing != "" {
		const prefix string = ",\"costing\":"
		out.RawString(prefix)
		out.String(string(in.Costing))
	}
	if true {
		const prefix string = ",\"directions_options\":"
		out.RawString(prefix)
		(in.DirectionsOptions).MarshalEasyJSON(out)
	}
	if true {
		const prefix string = ",\"trace_options\":"
		out.RawString(prefix)
		(in.TraceOptions).MarshalEasyJSON(out)
	}
	{
		const prefix string = ",\"linear_references\":"
		out.RawString(prefix)
		out.Bool(bool(in.LinearReferences))
	}
	{
		const prefix string = ",\"encoded_polyline\":"
		out.RawString(prefix)
		out.String(string(in.EncodedPolyline))
	}
	if in.ShapeMatch != "" {
		const prefix string = ",\"shape_match\":"
		out.RawString(prefix)
		out.String(string(in.ShapeMatch))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v TraceRouteRequest) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v TraceRouteRequest) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *TraceRouteRequest) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *TraceRouteRequest) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings(l, v)
}
func easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings1(in *jlexer.Lexer, out *TraceOptions) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "search_radius":
			if in.IsNull() {
				in.Skip()
				out.SearchRadius = nil
			} else {
				if out.SearchRadius == nil {
					out.SearchRadius = new(float64)
				}
				*out.SearchRadius = float64(in.Float64())
			}
		case "gps_accuracy":
			if in.IsNull() {
				in.Skip()
				out.GPSAccuracy = nil
			} else {
				if out.GPSAccuracy == nil {
					out.GPSAccuracy = new(float64)
				}
				*out.GPSAccuracy = float64(in.Float64())
			}
		case "breakage_distance":
			if in.IsNull() {
				in.Skip()
				out.BreakageDistance = nil
			} else {
				if out.BreakageDistance == nil {
					out.BreakageDistance = new(float64)
				}
				*out.BreakageDistance = float64(in.Float64())
			}
		case "interpolation_distance":
			if in.IsNull() {
				in.Skip()
				out.InterpolationDistance = nil
			} else {
				if out.InterpolationDistance == nil {
					out.InterpolationDistance = new(float64)
				}
				*out.InterpolationDistance = float64(in.Float64())
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings1(out *jwriter.Writer, in TraceOptions) {
	out.RawByte('{')
	first := true
	_ = first
	if in.SearchRadius != nil {
		const prefix string = ",\"search_radius\":"
		first = false
		out.RawString(prefix[1:])
		out.Float64(float64(*in.SearchRadius))
	}
	if in.GPSAccuracy != nil {
		const prefix string = ",\"gps_accuracy\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(*in.GPSAccuracy))
	}
	if in.BreakageDistance != nil {
		const prefix string = ",\"breakage_distance\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(*in.BreakageDistance))
	}
	if in.InterpolationDistance != nil {
		const prefix string = ",\"interpolation_distance\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(*in.InterpolationDistance))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v TraceOptions) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v TraceOptions) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *TraceOptions) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings1(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *TraceOptions) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings1(l, v)
}
func easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings2(in *jlexer.Lexer, out *TraceAttributesResponse) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "edges":
			if in.IsNull() {
				in.Skip()
				out.Edges = nil
			} else {
				in.Delim('[')
				if out.Edges == nil {
					if !in.IsDelim(']') {
						out.Edges = make([]Edge, 0, 0)
					} else {
						out.Edges = []Edge{}
					}
				} else {
					out.Edges = (out.Edges)[:0]
				}
				for !in.IsDelim(']') {
					var v4 Edge
					(v4).UnmarshalEasyJSON(in)
					out.Edges = append(out.Edges, v4)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "osm_changeset":
			out.OSMChangeSet = int(in.Int())
		case "confidence_score":
			out.ConfidenceScore = float64(in.Float64())
		case "shape":
			out.Shape = string(in.String())
		case "units":
			out.Units = string(in.String())
		case "admins":
			if in.IsNull() {
				in.Skip()
				out.Admins = nil
			} else {
				in.Delim('[')
				if out.Admins == nil {
					if !in.IsDelim(']') {
						out.Admins = make([]struct {
							StateCode   string `json:"state_code"`
							StateText   string `json:"state_text"`
							CountryText string `json:"country_text"`
							CountryCode string `json:"country_code"`
						}, 0, 1)
					} else {
						out.Admins = []struct {
							StateCode   string `json:"state_code"`
							StateText   string `json:"state_text"`
							CountryText string `json:"country_text"`
							CountryCode string `json:"country_code"`
						}{}
					}
				} else {
					out.Admins = (out.Admins)[:0]
				}
				for !in.IsDelim(']') {
					var v5 struct {
						StateCode   string `json:"state_code"`
						StateText   string `json:"state_text"`
						CountryText string `json:"country_text"`
						CountryCode string `json:"country_code"`
					}
					easyjsonD10c3f52Decode(in, &v5)
					out.Admins = append(out.Admins, v5)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings2(out *jwriter.Writer, in TraceAttributesResponse) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"edges\":"
		out.RawString(prefix[1:])
		if in.Edges == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v6, v7 := range in.Edges {
				if v6 > 0 {
					out.RawByte(',')
				}
				(v7).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"osm_changeset\":"
		out.RawString(prefix)
		out.Int(int(in.OSMChangeSet))
	}
	{
		const prefix string = ",\"confidence_score\":"
		out.RawString(prefix)
		out.Float64(float64(in.ConfidenceScore))
	}
	{
		const prefix string = ",\"shape\":"
		out.RawString(prefix)
		out.String(string(in.Shape))
	}
	{
		const prefix string = ",\"units\":"
		out.RawString(prefix)
		out.String(string(in.Units))
	}
	{
		const prefix string = ",\"admins\":"
		out.RawString(prefix)
		if in.Admins == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v8, v9 := range in.Admins {
				if v8 > 0 {
					out.RawByte(',')
				}
				easyjsonD10c3f52Encode(out, v9)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v TraceAttributesResponse) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings2(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v TraceAttributesResponse) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings2(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *TraceAttributesResponse) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings2(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *TraceAttributesResponse) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings2(l, v)
}
func easyjsonD10c3f52Decode(in *jlexer.Lexer, out *struct {
	StateCode   string `json:"state_code"`
	StateText   string `json:"state_text"`
	CountryText string `json:"country_text"`
	CountryCode string `json:"country_code"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "state_code":
			out.StateCode = string(in.String())
		case "state_text":
			out.StateText = string(in.String())
		case "country_text":
			out.CountryText = string(in.String())
		case "country_code":
			out.CountryCode = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD10c3f52Encode(out *jwriter.Writer, in struct {
	StateCode   string `json:"state_code"`
	StateText   string `json:"state_text"`
	CountryText string `json:"country_text"`
	CountryCode string `json:"country_code"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"state_code\":"
		out.RawString(prefix[1:])
		out.String(string(in.StateCode))
	}
	{
		const prefix string = ",\"state_text\":"
		out.RawString(prefix)
		out.String(string(in.StateText))
	}
	{
		const prefix string = ",\"country_text\":"
		out.RawString(prefix)
		out.String(string(in.CountryText))
	}
	{
		const prefix string = ",\"country_code\":"
		out.RawString(prefix)
		out.String(string(in.CountryCode))
	}
	out.RawByte('}')
}
func easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings3(in *jlexer.Lexer, out *TraceAttributesRequest) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "encoded_polyline":
			out.EncodedPolyline = string(in.String())
		case "costing":
			out.Costing = string(in.String())
		case "trace_options":
			(out.TraceOptions).UnmarshalEasyJSON(in)
		case "shape_match":
			out.ShapeMatch = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings3(out *jwriter.Writer, in TraceAttributesRequest) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"encoded_polyline\":"
		out.RawString(prefix[1:])
		out.String(string(in.EncodedPolyline))
	}
	if in.Costing != "" {
		const prefix string = ",\"costing\":"
		out.RawString(prefix)
		out.String(string(in.Costing))
	}
	if true {
		const prefix string = ",\"trace_options\":"
		out.RawString(prefix)
		(in.TraceOptions).MarshalEasyJSON(out)
	}
	if in.ShapeMatch != "" {
		const prefix string = ",\"shape_match\":"
		out.RawString(prefix)
		out.String(string(in.ShapeMatch))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v TraceAttributesRequest) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings3(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v TraceAttributesRequest) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings3(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *TraceAttributesRequest) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings3(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *TraceAttributesRequest) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings3(l, v)
}
func easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings4(in *jlexer.Lexer, out *Edge) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "names":
			if in.IsNull() {
				in.Skip()
				out.Names = nil
			} else {
				in.Delim('[')
				if out.Names == nil {
					if !in.IsDelim(']') {
						out.Names = make([]string, 0, 4)
					} else {
						out.Names = []string{}
					}
				} else {
					out.Names = (out.Names)[:0]
				}
				for !in.IsDelim(']') {
					var v10 string
					v10 = string(in.String())
					out.Names = append(out.Names, v10)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "length":
			out.Length = float64(in.Float64())
		case "speed":
			out.Speed = float64(in.Float64())
		case "road_class":
			out.RoadClass = string(in.String())
		case "begin_heading":
			out.BeginHeading = float64(in.Float64())
		case "end_heading":
			out.EndHeading = float64(in.Float64())
		case "begin_shape_index":
			out.BeginShapeIndex = int(in.Int())
		case "end_shape_index":
			out.EndShapeIndex = int(in.Int())
		case "traversability":
			out.Traversability = string(in.String())
		case "use":
			out.Use = string(in.String())
		case "toll":
			out.Toll = bool(in.Bool())
		case "unpaved":
			out.Unpaved = bool(in.Bool())
		case "tunnel":
			out.Tunnel = bool(in.Bool())
		case "bridge":
			out.Bridge = bool(in.Bool())
		case "roundabout":
			out.Roundabout = bool(in.Bool())
		case "internal_intersection":
			out.InternalIntersection = bool(in.Bool())
		case "drive_on_right":
			out.DriveOnRight = bool(in.Bool())
		case "surface":
			out.Surface = string(in.String())
		case "sign":
			easyjsonD10c3f52Decode1(in, &out.Sign)
		case "travel_mode":
			out.TravelMode = string(in.String())
		case "vehicle_type":
			out.VehicleType = string(in.String())
		case "pedestrian_type":
			out.PedestrianType = string(in.String())
		case "bicycle_type":
			out.BicycleType = string(in.String())
		case "transit_type":
			out.TransitType = string(in.String())
		case "id":
			out.ID = int(in.Int())
		case "way_id":
			out.WayID = int(in.Int())
		case "weighted_grade":
			out.WeightedGrade = float64(in.Float64())
		case "max_upward_grade":
			out.MaxUpwardGrade = float64(in.Float64())
		case "max_downward_grade":
			out.MaxDownwardGrade = float64(in.Float64())
		case "mean_elevation":
			out.MeanElevation = float64(in.Float64())
		case "lane_count":
			out.LaneCount = int(in.Int())
		case "cycle_lane":
			out.CycleLane = string(in.String())
		case "bicycle_network":
			out.BicycleNetwork = int(in.Int())
		case "sac_scale":
			out.SACScale = int(in.Int())
		case "shoulder":
			out.Shoulder = bool(in.Bool())
		case "sidewalk":
			out.Sidewalk = string(in.String())
		case "density":
			out.Density = float64(in.Float64())
		case "speed_limit":
			out.SpeedLimit = float64(in.Float64())
		case "truck_speed":
			out.TruckSpeed = float64(in.Float64())
		case "truck_route":
			out.TruckRoute = bool(in.Bool())
		case "end_node":
			easyjsonD10c3f52Decode2(in, &out.EndNode)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings4(out *jwriter.Writer, in Edge) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"names\":"
		out.RawString(prefix[1:])
		if in.Names == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v11, v12 := range in.Names {
				if v11 > 0 {
					out.RawByte(',')
				}
				out.String(string(v12))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"length\":"
		out.RawString(prefix)
		out.Float64(float64(in.Length))
	}
	{
		const prefix string = ",\"speed\":"
		out.RawString(prefix)
		out.Float64(float64(in.Speed))
	}
	{
		const prefix string = ",\"road_class\":"
		out.RawString(prefix)
		out.String(string(in.RoadClass))
	}
	{
		const prefix string = ",\"begin_heading\":"
		out.RawString(prefix)
		out.Float64(float64(in.BeginHeading))
	}
	{
		const prefix string = ",\"end_heading\":"
		out.RawString(prefix)
		out.Float64(float64(in.EndHeading))
	}
	{
		const prefix string = ",\"begin_shape_index\":"
		out.RawString(prefix)
		out.Int(int(in.BeginShapeIndex))
	}
	{
		const prefix string = ",\"end_shape_index\":"
		out.RawString(prefix)
		out.Int(int(in.EndShapeIndex))
	}
	{
		const prefix string = ",\"traversability\":"
		out.RawString(prefix)
		out.String(string(in.Traversability))
	}
	{
		const prefix string = ",\"use\":"
		out.RawString(prefix)
		out.String(string(in.Use))
	}
	{
		const prefix string = ",\"toll\":"
		out.RawString(prefix)
		out.Bool(bool(in.Toll))
	}
	{
		const prefix string = ",\"unpaved\":"
		out.RawString(prefix)
		out.Bool(bool(in.Unpaved))
	}
	{
		const prefix string = ",\"tunnel\":"
		out.RawString(prefix)
		out.Bool(bool(in.Tunnel))
	}
	{
		const prefix string = ",\"bridge\":"
		out.RawString(prefix)
		out.Bool(bool(in.Bridge))
	}
	{
		const prefix string = ",\"roundabout\":"
		out.RawString(prefix)
		out.Bool(bool(in.Roundabout))
	}
	{
		const prefix string = ",\"internal_intersection\":"
		out.RawString(prefix)
		out.Bool(bool(in.InternalIntersection))
	}
	{
		const prefix string = ",\"drive_on_right\":"
		out.RawString(prefix)
		out.Bool(bool(in.DriveOnRight))
	}
	{
		const prefix string = ",\"surface\":"
		out.RawString(prefix)
		out.String(string(in.Surface))
	}
	{
		const prefix string = ",\"sign\":"
		out.RawString(prefix)
		easyjsonD10c3f52Encode1(out, in.Sign)
	}
	{
		const prefix string = ",\"travel_mode\":"
		out.RawString(prefix)
		out.String(string(in.TravelMode))
	}
	{
		const prefix string = ",\"vehicle_type\":"
		out.RawString(prefix)
		out.String(string(in.VehicleType))
	}
	{
		const prefix string = ",\"pedestrian_type\":"
		out.RawString(prefix)
		out.String(string(in.PedestrianType))
	}
	{
		const prefix string = ",\"bicycle_type\":"
		out.RawString(prefix)
		out.String(string(in.BicycleType))
	}
	{
		const prefix string = ",\"transit_type\":"
		out.RawString(prefix)
		out.String(string(in.TransitType))
	}
	{
		const prefix string = ",\"id\":"
		out.RawString(prefix)
		out.Int(int(in.ID))
	}
	{
		const prefix string = ",\"way_id\":"
		out.RawString(prefix)
		out.Int(int(in.WayID))
	}
	{
		const prefix string = ",\"weighted_grade\":"
		out.RawString(prefix)
		out.Float64(float64(in.WeightedGrade))
	}
	{
		const prefix string = ",\"max_upward_grade\":"
		out.RawString(prefix)
		out.Float64(float64(in.MaxUpwardGrade))
	}
	{
		const prefix string = ",\"max_downward_grade\":"
		out.RawString(prefix)
		out.Float64(float64(in.MaxDownwardGrade))
	}
	{
		const prefix string = ",\"mean_elevation\":"
		out.RawString(prefix)
		out.Float64(float64(in.MeanElevation))
	}
	{
		const prefix string = ",\"lane_count\":"
		out.RawString(prefix)
		out.Int(int(in.LaneCount))
	}
	{
		const prefix string = ",\"cycle_lane\":"
		out.RawString(prefix)
		out.String(string(in.CycleLane))
	}
	{
		const prefix string = ",\"bicycle_network\":"
		out.RawString(prefix)
		out.Int(int(in.BicycleNetwork))
	}
	{
		const prefix string = ",\"sac_scale\":"
		out.RawString(prefix)
		out.Int(int(in.SACScale))
	}
	{
		const prefix string = ",\"shoulder\":"
		out.RawString(prefix)
		out.Bool(bool(in.Shoulder))
	}
	{
		const prefix string = ",\"sidewalk\":"
		out.RawString(prefix)
		out.String(string(in.Sidewalk))
	}
	{
		const prefix string = ",\"density\":"
		out.RawString(prefix)
		out.Float64(float64(in.Density))
	}
	{
		const prefix string = ",\"speed_limit\":"
		out.RawString(prefix)
		out.Float64(float64(in.SpeedLimit))
	}
	{
		const prefix string = ",\"truck_speed\":"
		out.RawString(prefix)
		out.Float64(float64(in.TruckSpeed))
	}
	{
		const prefix string = ",\"truck_route\":"
		out.RawString(prefix)
		out.Bool(bool(in.TruckRoute))
	}
	{
		const prefix string = ",\"end_node\":"
		out.RawString(prefix)
		easyjsonD10c3f52Encode2(out, in.EndNode)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Edge) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings4(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Edge) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonD10c3f52EncodeGithubComLittlemonkeyltdValhallaGoBindings4(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Edge) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings4(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Edge) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD10c3f52DecodeGithubComLittlemonkeyltdValhallaGoBindings4(l, v)
}
func easyjsonD10c3f52Decode2(in *jlexer.Lexer, out *struct {
	IntersectingEdges []struct {
		BeginHeading            float64 `json:"begin_heading"`
		FromEdgeNameConsistency bool    `json:"from_edge_name_consistency"`
		ToEdgeNameConsistency   bool    `json:"to_edge_name_consistency"`
		Driveability            string  `json:"drivability"`
		Cyclability             string  `json:"cyclability"`
		Walkability             string  `json:"walkability"`
		Use                     string  `json:"use"`
		RoadClass               string  `json:"road_class"`
	} `json:"intersecting_edges"`
	ElapsedTime float64 `json:"elapsed_time"`
	AdminIndex  int     `json:"admin_index"`
	Type        string  `json:"type"`
	Fork        bool    `json:"fork"`
	TimeZone    string  `json:"time_zone"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "intersecting_edges":
			if in.IsNull() {
				in.Skip()
				out.IntersectingEdges = nil
			} else {
				in.Delim('[')
				if out.IntersectingEdges == nil {
					if !in.IsDelim(']') {
						out.IntersectingEdges = make([]struct {
							BeginHeading            float64 `json:"begin_heading"`
							FromEdgeNameConsistency bool    `json:"from_edge_name_consistency"`
							ToEdgeNameConsistency   bool    `json:"to_edge_name_consistency"`
							Driveability            string  `json:"drivability"`
							Cyclability             string  `json:"cyclability"`
							Walkability             string  `json:"walkability"`
							Use                     string  `json:"use"`
							RoadClass               string  `json:"road_class"`
						}, 0, 0)
					} else {
						out.IntersectingEdges = []struct {
							BeginHeading            float64 `json:"begin_heading"`
							FromEdgeNameConsistency bool    `json:"from_edge_name_consistency"`
							ToEdgeNameConsistency   bool    `json:"to_edge_name_consistency"`
							Driveability            string  `json:"drivability"`
							Cyclability             string  `json:"cyclability"`
							Walkability             string  `json:"walkability"`
							Use                     string  `json:"use"`
							RoadClass               string  `json:"road_class"`
						}{}
					}
				} else {
					out.IntersectingEdges = (out.IntersectingEdges)[:0]
				}
				for !in.IsDelim(']') {
					var v13 struct {
						BeginHeading            float64 `json:"begin_heading"`
						FromEdgeNameConsistency bool    `json:"from_edge_name_consistency"`
						ToEdgeNameConsistency   bool    `json:"to_edge_name_consistency"`
						Driveability            string  `json:"drivability"`
						Cyclability             string  `json:"cyclability"`
						Walkability             string  `json:"walkability"`
						Use                     string  `json:"use"`
						RoadClass               string  `json:"road_class"`
					}
					easyjsonD10c3f52Decode3(in, &v13)
					out.IntersectingEdges = append(out.IntersectingEdges, v13)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "elapsed_time":
			out.ElapsedTime = float64(in.Float64())
		case "admin_index":
			out.AdminIndex = int(in.Int())
		case "type":
			out.Type = string(in.String())
		case "fork":
			out.Fork = bool(in.Bool())
		case "time_zone":
			out.TimeZone = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD10c3f52Encode2(out *jwriter.Writer, in struct {
	IntersectingEdges []struct {
		BeginHeading            float64 `json:"begin_heading"`
		FromEdgeNameConsistency bool    `json:"from_edge_name_consistency"`
		ToEdgeNameConsistency   bool    `json:"to_edge_name_consistency"`
		Driveability            string  `json:"drivability"`
		Cyclability             string  `json:"cyclability"`
		Walkability             string  `json:"walkability"`
		Use                     string  `json:"use"`
		RoadClass               string  `json:"road_class"`
	} `json:"intersecting_edges"`
	ElapsedTime float64 `json:"elapsed_time"`
	AdminIndex  int     `json:"admin_index"`
	Type        string  `json:"type"`
	Fork        bool    `json:"fork"`
	TimeZone    string  `json:"time_zone"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"intersecting_edges\":"
		out.RawString(prefix[1:])
		if in.IntersectingEdges == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v14, v15 := range in.IntersectingEdges {
				if v14 > 0 {
					out.RawByte(',')
				}
				easyjsonD10c3f52Encode3(out, v15)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"elapsed_time\":"
		out.RawString(prefix)
		out.Float64(float64(in.ElapsedTime))
	}
	{
		const prefix string = ",\"admin_index\":"
		out.RawString(prefix)
		out.Int(int(in.AdminIndex))
	}
	{
		const prefix string = ",\"type\":"
		out.RawString(prefix)
		out.String(string(in.Type))
	}
	{
		const prefix string = ",\"fork\":"
		out.RawString(prefix)
		out.Bool(bool(in.Fork))
	}
	{
		const prefix string = ",\"time_zone\":"
		out.RawString(prefix)
		out.String(string(in.TimeZone))
	}
	out.RawByte('}')
}
func easyjsonD10c3f52Decode3(in *jlexer.Lexer, out *struct {
	BeginHeading            float64 `json:"begin_heading"`
	FromEdgeNameConsistency bool    `json:"from_edge_name_consistency"`
	ToEdgeNameConsistency   bool    `json:"to_edge_name_consistency"`
	Driveability            string  `json:"drivability"`
	Cyclability             string  `json:"cyclability"`
	Walkability             string  `json:"walkability"`
	Use                     string  `json:"use"`
	RoadClass               string  `json:"road_class"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "begin_heading":
			out.BeginHeading = float64(in.Float64())
		case "from_edge_name_consistency":
			out.FromEdgeNameConsistency = bool(in.Bool())
		case "to_edge_name_consistency":
			out.ToEdgeNameConsistency = bool(in.Bool())
		case "drivability":
			out.Driveability = string(in.String())
		case "cyclability":
			out.Cyclability = string(in.String())
		case "walkability":
			out.Walkability = string(in.String())
		case "use":
			out.Use = string(in.String())
		case "road_class":
			out.RoadClass = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD10c3f52Encode3(out *jwriter.Writer, in struct {
	BeginHeading            float64 `json:"begin_heading"`
	FromEdgeNameConsistency bool    `json:"from_edge_name_consistency"`
	ToEdgeNameConsistency   bool    `json:"to_edge_name_consistency"`
	Driveability            string  `json:"drivability"`
	Cyclability             string  `json:"cyclability"`
	Walkability             string  `json:"walkability"`
	Use                     string  `json:"use"`
	RoadClass               string  `json:"road_class"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"begin_heading\":"
		out.RawString(prefix[1:])
		out.Float64(float64(in.BeginHeading))
	}
	{
		const prefix string = ",\"from_edge_name_consistency\":"
		out.RawString(prefix)
		out.Bool(bool(in.FromEdgeNameConsistency))
	}
	{
		const prefix string = ",\"to_edge_name_consistency\":"
		out.RawString(prefix)
		out.Bool(bool(in.ToEdgeNameConsistency))
	}
	{
		const prefix string = ",\"drivability\":"
		out.RawString(prefix)
		out.String(string(in.Driveability))
	}
	{
		const prefix string = ",\"cyclability\":"
		out.RawString(prefix)
		out.String(string(in.Cyclability))
	}
	{
		const prefix string = ",\"walkability\":"
		out.RawString(prefix)
		out.String(string(in.Walkability))
	}
	{
		const prefix string = ",\"use\":"
		out.RawString(prefix)
		out.String(string(in.Use))
	}
	{
		const prefix string = ",\"road_class\":"
		out.RawString(prefix)
		out.String(string(in.RoadClass))
	}
	out.RawByte('}')
}
func easyjsonD10c3f52Decode1(in *jlexer.Lexer, out *struct {
	ExitNumber []string `json:"exit_number"`
	ExitBranch []string `json:"exit_branch"`
	ExitToward []string `json:"exit_toward"`
	ExitName   []string `json:"exit_name"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "exit_number":
			if in.IsNull() {
				in.Skip()
				out.ExitNumber = nil
			} else {
				in.Delim('[')
				if out.ExitNumber == nil {
					if !in.IsDelim(']') {
						out.ExitNumber = make([]string, 0, 4)
					} else {
						out.ExitNumber = []string{}
					}
				} else {
					out.ExitNumber = (out.ExitNumber)[:0]
				}
				for !in.IsDelim(']') {
					var v16 string
					v16 = string(in.String())
					out.ExitNumber = append(out.ExitNumber, v16)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "exit_branch":
			if in.IsNull() {
				in.Skip()
				out.ExitBranch = nil
			} else {
				in.Delim('[')
				if out.ExitBranch == nil {
					if !in.IsDelim(']') {
						out.ExitBranch = make([]string, 0, 4)
					} else {
						out.ExitBranch = []string{}
					}
				} else {
					out.ExitBranch = (out.ExitBranch)[:0]
				}
				for !in.IsDelim(']') {
					var v17 string
					v17 = string(in.String())
					out.ExitBranch = append(out.ExitBranch, v17)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "exit_toward":
			if in.IsNull() {
				in.Skip()
				out.ExitToward = nil
			} else {
				in.Delim('[')
				if out.ExitToward == nil {
					if !in.IsDelim(']') {
						out.ExitToward = make([]string, 0, 4)
					} else {
						out.ExitToward = []string{}
					}
				} else {
					out.ExitToward = (out.ExitToward)[:0]
				}
				for !in.IsDelim(']') {
					var v18 string
					v18 = string(in.String())
					out.ExitToward = append(out.ExitToward, v18)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "exit_name":
			if in.IsNull() {
				in.Skip()
				out.ExitName = nil
			} else {
				in.Delim('[')
				if out.ExitName == nil {
					if !in.IsDelim(']') {
						out.ExitName = make([]string, 0, 4)
					} else {
						out.ExitName = []string{}
					}
				} else {
					out.ExitName = (out.ExitName)[:0]
				}
				for !in.IsDelim(']') {
					var v19 string
					v19 = string(in.String())
					out.ExitName = append(out.ExitName, v19)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonD10c3f52Encode1(out *jwriter.Writer, in struct {
	ExitNumber []string `json:"exit_number"`
	ExitBranch []string `json:"exit_branch"`
	ExitToward []string `json:"exit_toward"`
	ExitName   []string `json:"exit_name"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"exit_number\":"
		out.RawString(prefix[1:])
		if in.ExitNumber == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v20, v21 := range in.ExitNumber {
				if v20 > 0 {
					out.RawByte(',')
				}
				out.String(string(v21))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"exit_branch\":"
		out.RawString(prefix)
		if in.ExitBranch == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v22, v23 := range in.ExitBranch {
				if v22 > 0 {
					out.RawByte(',')
				}
				out.String(string(v23))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"exit_toward\":"
		out.RawString(prefix)
		if in.ExitToward == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v24, v25 := range in.ExitToward {
				if v24 > 0 {
					out.RawByte(',')
				}
				out.String(string(v25))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"exit_name\":"
		out.RawString(prefix)
		if in.ExitName == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v26, v27 := range in.ExitName {
				if v26 > 0 {
					out.RawByte(',')
				}
				out.String(string(v27))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
